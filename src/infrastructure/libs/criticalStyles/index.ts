import { chown, stat } from 'fs';
import React from 'react';
import {createLink} from 'used-styles';
// @ts-ignore
import {importAssets} from 'webpack-imported';

type ChunkLoadingTrackerType = {
    /**
     * chunkShouldBeLoaded contains "webpackChunkName" keys
     */
     chunkShouldBeLoaded: Set<string>;
    // stats generated by 'webpack-imported' plugin
    stats: any;
}

export class ChunkLoadingTracker implements ChunkLoadingTrackerType {
	// stats = webpack-imported stats file
	chunkShouldBeLoaded: Set<string> = new Set();
	stats: any;

	constructor() {
		// this.stats = stats;
		this.collect = this.collect.bind(this);
	}

	// // collect by chunk
	// collect(chunkName: string) {
	//     const {styles} = importAssets(this.stats, chunkName);
	//     // should be loaded stats
	//     const stats = styles.load;

	//     this.requestedChunks.set(chunkName, stats);
	// }

	// это решение лучше, так как после импорта ассетов для чанка мы всегда будем держать
	// только действительно нужные стили для чанков
	// и можем проверять заргужать стили или нет (из стрима) сверив их с chunkShouldBeLoaded
	collect(chunkName: string) {
		const {styles} = importAssets(this.stats, chunkName);
		const stats = styles.load;

		console.log({stats, styles, chunkName});

		if(!stats) return;

		for(let chunk of stats) {
			this.chunkShouldBeLoaded.add(chunk);
		}
	}

	initStats(stats: any) {
		// + load all init bundle styles
		this.stats = JSON.parse(stats);
		return this;
	}
}

export const chunkLoadingTrackerSingleton = new ChunkLoadingTracker();

// in stream
// we cant use it in alterProjectStyles because of we need STREAM

// const instance = new ChunkLoadingTracker();

// const styleStream = createStyleStream((chunk: string) => {
//     // avoid adding style to stream because of it shouldnot load
//     // we should return empty string because 'used-styles' anyway will concat it with chunk
//     if(!instance.chunkShouldBeLoaded.has(chunk)) return '';
//     return createLink(chunk);
// });


// ####################### import decorator flow

// returns module
type TrackLoadedChunkCallbackType = (name: string) => void;
/**
 * decorator for chunk loader
 * which notify which chunk name whould be loaded
 * actually only need for server
 * @param name - name of chunk which will be loaded
 */
export const trackLoadedChunk = <T extends LoadFnType>(loadFn: T, name: string, callback: TrackLoadedChunkCallbackType) => {
	const promise = React.lazy(loadFn);

	// first of all request fot chunk
	// because of callback has slow sync calculcations
	callback(name);

	return promise;
};


type LoadFnType = () => Promise<any>

export const dynamicLoad = typeof window === 'undefined' ? (loadFn: LoadFnType, name?: string) => {
	return trackLoadedChunk(loadFn, name, chunkLoadingTrackerSingleton.collect);
} : (loadFn: LoadFnType) => {
	return React.lazy(loadFn);
};